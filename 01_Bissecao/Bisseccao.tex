\documentclass[final,3p,12pt]{elsarticle}

% \documentclass[preprint,12pt]{elsarticle}

%% Use the option review to obtain double line spacing
%% \documentclass[authoryear,preprint,review,12pt]{elsarticle}

%% Use the options 1p,twocolumn; 3p; 3p,twocolumn; 5p; or 5p,twocolumn
%% for a journal layout:
% \documentclass[final,1p,times]{elsarticle}
%% \documentclass[final,1p,times,twocolumn]{elsarticle}
% \documentclass[final,3p,times]{elsarticle}
%% \documentclass[final,3p,times,twocolumn]{elsarticle}
% \documentclass[final,5p,times]{elsarticle}
%% \documentclass[final,5p,times,twocolumn]{elsarticle}
\usepackage[portuguese]{babel}

%% For including figures, graphicx.sty has been loaded in
%% elsarticle.cls. If you prefer to use the old commands
%% please give \usepackage{epsfig}

%% The amssymb package provides various useful mathematical symbols
\usepackage{amssymb}
\usepackage{amsmath}

\usepackage{multirow}

\usepackage{pgfplots}
\usepackage{placeins}
\usepackage{hyperref}

%=========== Gloabal Tikz settings
% \pgfplotsset{compat=newest}
% \usetikzlibrary{math}
% \pgfplotsset{
%     height = 10cm,
%     width = 10cm,
%     tick pos = left,
%     legend style={at={(0.98,0.30)}, anchor=east},
%     legend cell align=left,     
%     }
%  \pgfkeys{
%     /pgf/number format/.cd,
%     fixed,
%     precision = 1,
%     set thousands separator = {}
% }

%% The amsthm package provides extended theorem environments
%% \usepackage{amsthm}

%% The lineno packages adds line numbers. Start line numbering with
%% \begin{linenumbers}, end it with \end{linenumbers}. Or switch it on
%% for the whole article with \linenumbers.
%% \usepackage{lineno}

\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.98,0.98,0.98}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

% \journal{Nuclear Physics B}

\begin{document}

\begin{frontmatter}

%% Title, authors and addresses

%% use the tnoteref command within \title for footnotes;
%% use the tnotetext command for theassociated footnote;
%% use the fnref command within \author or \address for footnotes;
%% use the fntext command for theassociated footnote;
%% use the corref command within \author for corresponding author footnotes;
%% use the cortext command for theassociated footnote;
%% use the ead command for the email address,
%% and the form \ead[url] for the home page:
%% \title{Title\tnoteref{label1}}
%% \tnotetext[label1]{}
%% \author{Name\corref{cor1}\fnref{label2}}
%% \ead{email address}
%% \ead[url]{home page}
%% \fntext[label2]{}
%% \cortext[cor1]{}
%% \affiliation{organization={},
%%             addressline={},
%%             city={},
%%             postcode={},
%%             state={},
%%             country={}}
%% \fntext[label3]{}

\title{Proposta de Cálculo de Parâmetros de Perfuração de Poços de Petróleo a partir de Coordenadas Espaciais com o Método da Bissecção\tnoteref{label_title}}
\tnotetext[label_title]{Relatório integrante dos requisitos da disciplina IM253: Métodos Numéricos para Fenômenos de Transporte.}

%% use optional labels to link authors explicitly to addresses:
%% \author[label1,label2]{}
%% \affiliation[label1]{organization={},
%%             addressline={},
%%             city={},
%%             postcode={},
%%             state={},
%%             country={}}
%%
%% \affiliation[label2]{organization={},
%%             addressline={},
%%             city={},
%%             postcode={},
%%             state={},
%%             country={}}

\author{Tiago C. A. Amorim\fnref{label_author}}
\tnotetext[label_author]{Atualmente cursando doutorado no Departamento de Engenharia de Petróleo da Faculdade de Engenharia Mecânica da UNICAMP (Campinas/SP, Brasil).}
\ead{t100675@dac.unicamp.br}
\affiliation[Tiago C. A. Amorim]{organization={Petrobras},%Department and Organization
addressline={Av. Henrique Valadares, 28}, 
city={Rio de Janeiro},
postcode={20231-030}, 
state={RJ},
country={Brasil}}

\begin{abstract}
    O Método de Mínima Curvatura é reconhecido como o mais aceito no cálculo de trajetória de poços de petróleo. A formulação para cálculo de coordenadas cartesianas a partir de parâmetros de perfuração é direta, e o cálculo inverso não tem formulação direta.

    Neste trabalho é proposto um algoritmo para calcular parâmetros de perfuração a partir de coordenadas cartesianas. O algoritmo proposto tem a forma $g(x)=x$, e encontrar uma solução passa por um problema de encontrar a raiz de uma função. 

    Foi aplicado o Método da Bissecção para resolver o problema proposto. O testes realizados mostraram boa coerência entre os valores estimados com o processo iterativo e as respectivas respostas exatas.

\end{abstract}


%%Graphical abstract
% \begin{graphicalabstract}
%\includegraphics{grabs}
% \end{graphicalabstract}

%%Research highlights
% \begin{highlights}
% \item Research highlight 1
% \item Research highlight 2
% \end{highlights}

\begin{keyword}
    Método da Mínima Curvatura \sep Método da Bissecção 
%% keywords here, in the form: keyword \sep keyword

%% PACS codes here, in the form: \PACS code \sep code

%% MSC codes here, in the form: \MSC code \sep code
%% or \MSC[2008] code \sep code (2000 is the default)

\end{keyword}

\end{frontmatter}

%% \linenumbers

%% main text
\section{Introdução}

O desenvolvimento de técnicas para construção de poços direcionais na indústria do petróleo iniciou nos anos 1920 \cite{international2015iadc}. A construção de poços direcionais pode ter diferentes objetivos, desde acessar acumulações que seriam difíceis de serem alcançadas com poços verticais (áreas montanhosas, acumulações abaixo de leitos de rios etc.), para aumento da produtividade (maior exposição da formação portadora de hidrocarbonetos) ou até para interceptar outros poços (poços de alívio em situações de \emph{blowout}\footnote{Um \emph{blowout} é um evento indesejado, de produção descontrolada de um poço.}).

O Método da Mínima Curvatura é largamente aceito como o método padrão para o cálculo de trajetória de poços \cite{10.2118/84246-MS}. Neste método a geometria do poço é descrita como uma série de arcos circulares e linhas retas. A transformação de parâmetros de perfuração ($\Delta$S, $\theta$, $\phi$) em coordenadas cartesianas ($\Delta$N, $\Delta$E, $\Delta$V) tem formulação explícita. A operação inversa, de coordenadas cartesianas em parâmetros de perfuração não tem formulação explícita.

No planejamento de novos poços de petróleo as coordenadas espaciais são conhecidas, e é necessário calcular os futuros parâmetros de perfuração. Os parâmetros de perfuração são utilizados para diferentes análises, como o de máximo DLS (\emph{dogleg severity}), que é uma medida da curvatura de um poço entre dois pontos de medida, usualmente expressa em graus por metro.

Este relatório apresenta uma proposta de metodologia para cálculo dos parâmetros de perfuração a partir das coordenadas cartesianas de pontos ao longo da geometria do poço. A formulação foi derivada das fórmulas utilizadas no Método da Mínima Curvatura, e é implícita. Para resolver o problema foi aplicado o Método da Bissecção.

\section{Metodologia}

\subsection{Método da Mínima Curvatura}

Ao longo da perfuração de um poço de petróleo são realizadas medições do comprimento perfurado (comumente chamado de comprimento medido), inclinação (ângulo com relação à direção vertical) e azimute (ângulo entre a direção horizontal e o norte). A partir das coordenadas geográficas do ponto inicial do poço e deste conjunto de medições ao longo da trajetória, é possível calcular as coordenadas cartesianas (N, E, V) de qualquer posição do poço. A figura \ref{fig:parametros} apresenta um esquema dos parâmetros de perfuração de um poço direcional:
\begin{itemize}
    \item $\Delta$S: comprimento medido entre dois pontos ao longo da trajetória.
    \item $\theta$: inclinação do poço no ponto atual.
    \item $\phi$: azimute do poço no ponto atual.
    \item $\alpha$: curvatura entre dois pontos ao longo da trajetória.
\end{itemize}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\textwidth]{Parametros}
    \caption{Parâmetros de perfuração entre dois pontos ao longo de um poço direcional.}
    \label{fig:parametros}
\end{figure}


As fórmulas que associam os parâmetros de perfuração e as coordenadas cartesianas de dois pontos ao longo de um poço direcional segundo o Método da Mínima Curvatura são \cite{10.2118/84246-MS}:

\begin{equation} \label{eq:deltaN}
    \Delta N = \frac{\Delta S}{2} f(\alpha) (\sin \theta_1 \cos \phi_1 + \sin \theta_2 \cos \phi_2)
\end{equation}
\begin{equation} \label{eq:deltaE}
    \Delta E = \frac{\Delta S}{2} f(\alpha) (\sin \theta_1 \sin \phi_1 + \sin \theta_2 \sin \phi_2)
\end{equation}
\begin{equation} \label{eq:deltaV}
    \Delta V = \frac{\Delta S}{2} f(\alpha) (\cos \theta_1 + \cos \theta_2)
\end{equation}

\begin{equation} \label{eq:alpha}
    \alpha = 2 \arcsin \sqrt{ \sin^2 \frac{\theta_2-\theta_1}{2} + \sin \theta_1 \sin \theta_2 \sin^2 \frac{\phi_2-\phi_1}{2} }
\end{equation}
\begin{equation} \label{eq:f_alpha}
    f(\alpha)= \begin{cases}
        1+\frac{\alpha^2}{12}\{1+\frac{\alpha^2}{10}[1+\frac{\alpha^2}{168}(1+\frac{31\alpha^2}{18})]\},&\text{se } \alpha<0,02 \\
        \frac{2}{\alpha}\tan{\frac{\alpha}{2}},&\text{c.c. }  
    \end{cases}
\end{equation}

A proposta de método para calcular os parâmetros de perfuração a partir das coordenadas cartesianas parte de manipulações das equações \ref{eq:deltaN}, \ref{eq:deltaE} e \ref{eq:deltaV}. É assumido que para calcular os parâmtros de perfuração entre dois pontos quaisquer são conhecidos os parâmetros de perfuração do ponto inicial\footnote{Para o primeiro ponto da trajetória é assumido um poço na vertical: $\theta=0$, $\phi=0$.} ($\theta_1$, $\phi_1$) e as distâncias cartesianas entre os pontos ($\Delta$N,$\Delta$E, $\Delta$V). O objetivo é calcular $\theta_1$, $\phi_1$ e $\Delta$S.

É possível inverter a equação \ref{eq:deltaV} para obter uma expressão para $\theta_2$:
\begin{equation} \label{eq:cos_theta2}
    \cos \theta_2 = 2 \frac{\Delta V}{\Delta S f(\alpha)} - \cos \theta_1 
\end{equation}

Dividindo a equação \ref{eq:deltaN} pela equação \ref{eq:deltaE} obtém-se duas expressões para $\phi_2$:

\begin{equation} \label{eq:sin_phi2}
    \sin \phi_2 = \frac{-\Delta N \Delta \Psi}{\Delta H^2} \left( \frac{\sin \theta_1}{\sin \theta_2} \right) + \frac{\Delta E}{\Delta H^2} \sqrt{\Delta H^2 - \Delta \Psi^2 \left( \frac{\sin \theta_1}{\sin \theta_2} \right)^2} 
\end{equation}
\begin{equation} \label{eq:cos_phi2}
    \cos \phi_2 = \frac{\Delta E \Delta \Psi}{\Delta H^2} \left( \frac{\sin \theta_1}{\sin \theta_2} \right) + \frac{\Delta N}{\Delta H^2} \sqrt{\frac{1}{\Delta H^2} - \Delta \Psi^2 \left( \frac{\sin \theta_1}{\sin \theta_2} \right)^2} 
\end{equation}
\begin{align*}
    \intertext{onde}
    \Delta \Psi &= \Delta N \sin \phi_1 - \Delta E \cos \phi_1 \\
    \Delta H^2 &= \Delta N^2 + \Delta E^2
\end{align*}

Fazendo a soma dos quadrados das equações \ref{eq:deltaN}, \ref{eq:deltaE} e \ref{eq:deltaV} é possível obter uma expressão para $\Delta S f(\alpha)$:
\begin{equation} \label{eq:DeltaSfa}
    \Delta S f(\alpha) = 2 \sqrt{\frac{\Delta N^2 + \Delta E^2 + \Delta V^2}{A^2+B^2+C^2}}
\end{equation}
\begin{align*}
    \intertext{onde}
    A &= \sin \theta_1 \cos \phi_1 + \sin \theta_2 \cos \phi_2 \\
    B &= \sin \theta_1 \sin \phi_1 + \sin \theta_2 \sin \phi_2 \\
    C &= \cos \theta_1 + \cos \theta_2
\end{align*}
Com as equações propostas é possível construir uma função do tipo $g(x)=x$:

\begin{enumerate}
    \item Assumir um valor inicial de $\Delta S f(\alpha)$.
    \item Calcular $\cos \theta_2$ com a equação \ref{eq:cos_theta2}.
    \item Calcular $\sin \phi_2$ com a equação \ref{eq:sin_phi2}.
    \item Calcular $\cos \phi_2$ com a equação \ref{eq:cos_phi2}.
    \item Calcular $\Delta S f(\alpha)$ com a equação \ref{eq:DeltaSfa}.
\end{enumerate}

Ao utilizar $\Delta S f(\alpha)$ como parâmetro principal, evita-se calcular $\alpha$ e $f(\alpha)$ durante o processo. O valor de $\phi_2$ só precisa ser calculado ao final, evitando usar $\arccos$ ou $\arcsin$ muitas vezes. Alguns cuidados adicionais precisam ser tomados ao utilizar este algoritmo:

\begin{itemize}
    \item O valor mínimo de $\Delta S f(\alpha)$ é uma linha reta entre os pontos:
    \begin{align*}
        \Delta S f(\alpha) \geq \sqrt{\Delta N^2 + \Delta E^2 + \Delta V^2}
    \end{align*}
    \item $\Delta S f(\alpha)$ tem um segundo limite inferior a ser atendido, definido pelos valores limite da equação \ref{eq:cos_theta2} quando $\Delta V \neq 0$:
    \begin{align*}
        \Delta S f(\alpha) \geq \begin{cases}
            \Delta V \frac{2}{\cos \theta_1+1},&\text{se } \Delta V > 0 \\
            \Delta V \frac{2}{\cos \theta_1-1},&\text{se } \Delta V < 0  
        \end{cases}
    \end{align*}
    \item Se $\theta_2 = 0$, então $\phi_2$ fica indefinido. Neste caso a recomendação é fazer $\phi_2 = \phi_1$. 
    \item Se $\Delta N = \Delta E = 0$ então $|\phi_1 - \phi_2| = \pi$.
\end{itemize}

    \subsection{Método da Bissecção}
    
    Uma equação do tipo $g(x)=x$ pode ser resolvida buscando a raiz de $f(x) = x - g(x)$. Nesta primeira tentativa foi implementado o Método da Bissecção para buscar o resultado do problema proposto. O algoritmo foi baseado no pseudo-código descrito em \cite{burden2016analise}. O Método da Bissecção baseia-se no teorema do valor médio. O intervalo de busca pela raiz é sucessivamente divido em dois. O método tem garantia de que a raiz pertence ao intervalo ao manter os valores da função avaliada nos limites do intervalo com sinais opostos\footnote{Assumindo que o intervalo inicial fornecido também tem esta propriedade.}. 

    De modo simplificado o Método da Bissecção pode ser descrito como:
    
    \begin{enumerate}
        \item Definir $x_a$ e $x_b$ de modo que $sinal(f(x_a)) \neq sinal(f(x_b))$.
        \item Calcular $f(x_a)$ e $f(x_b)$.
        \item Calcular $x_{medio} = x_a + \frac{x_b - x_a}{2}$ e $f(x_{medio})$.
        \item Se $sinal(f(x_{medio})) = sinal(f(x_a))$ então $x_a = x_{medio}$.
        \item Se $sinal(f(x_{medio})) = sinal(f(x_b))$ então $x_b = x_{medio}$.
        \item Se não atingiu critério de convergência, retornar para passo 2.
        \item Retornar $x_{medio}$.
    \end{enumerate}
    
    Foram adicionados critérios adicionais ao algoritmo para controlar o processo iterativo:

    \begin{itemize}
        \item Foram implementados dois métodos de cálculo do critério de convergência:
        \begin{itemize}
            \item Critério \emph{Direto}: $|x_i - x_{i-1}|$.
            \item Critério \emph{Relativo}\footnote{Caso $|x_i| < \epsilon$, é utilizado $|x_{i-1}|$ no denominador. E se também $|x_{i-1}| < \epsilon$ o valor da convergência é considerado \emph{zero}!}: $\frac{|x_i - x_{i-1}|}{|x_i|}$.
        \end{itemize}
        \item No início do código é verificado se $|x_b - x_a| < \zeta$, onde $\zeta$ é calculado em função do critério de convergência estabelecido\footnote{Definindo $c_{lim}$ o limite de convergência, se for utilizado o critério de convergência \emph{direto} então $\zeta = c_{lim}$. Se for utilizado o critério de convergência relativo então $\zeta = c_{lim} \min{|x_a|,|x_b|}$ (a avaliação do menor valor segue as mesmas regras do cálculo do critério de convergência, ignorando qualquer $|x| < \epsilon$ e retorna \emph{zero} caso ambos sejam valores pequenos).}. Se for \emph{verdadeiro}, não é feito o \emph{loop} do método. 
        \item Se $sinal(f(x_a)) = sinal(f(x_b))$ o código apresenta uma mensagem de alerta e não é feito o \emph{loop} do método. Optou-se por não gerar um erro, e mesmo neste caso é retornado um valor.
        \item É feito um término prematuro do processo iterativo caso algum $|f(x)| < \epsilon$. O valor padrão de $\epsilon$ é $10^{-7}$ (variável \verb|epsilon| no código). Este teste também é feito antes de entrar no \emph{loop}.
        \item Antes de sair da função, são comparados os três últimos resultados guardados ($f(x_a)$, $f(x_b)$, $f(x_{medio})$) e é retornado o valor de $x$ com $f(x)$ mais próximo de zero.
    \end{itemize}
    
    \section{Resultados}
    
    Para facilitar a análise da qualidade do código desenvolvido, foram criadas funções que realizam diversos testes onde a resposta exata é conhecida:

    \begin{description}
        \item[tests\textunderscore bissection()] Testa o Método da Bissecção em diferentes funções: linear, quadrática, exponencial e com sen/cos. Também foram apicados casos específicos para o algoritmo tratar: raiz em um dos limites, uso de critério de convergência relativo, saída do \emph{loop} sem atingir o critério de convergência, má definição do intervalo inicial ($sinal(f(x_a)) = sinal(f(x_b))$) e intervalo inicial muito pequeno ($|x_b - x_a| < \zeta$).
        
        \item[tests\textunderscore minimum\textunderscore curvature()] Testa as funções implementadas para cálculo de coordenadas cartesianas em função de parâmetros de perfuração (cálculo direto), e de parâmetros de perfuração em função de coordenadas cartesianas (cálculo iterativo).
    \end{description}

    Algumas definições que foram feitas no código que implementa o Método da Bissecção são resultado dos testes realizados.

    A definição de um critério de parada prematura se mostrou importante para evitar que o método continue buscando uma raiz quando já encontrou uma solução \emph{aceitável}. A definição deste limite $|f(x)| < \epsilon = 10^{-7}$ foi empírica e deve ser revista em função do problema a ser resolvido.
    
    Todas as funções foram definidas para trabalhar com números do tipo \verb|double|. Inicialmente as funções estavam definidas para trabalhar com \verb|float|, mas estes mostraram não conseguirem trabalhar com valores de convergência muito baixos. A avaliação da função $f(x) = -3x+0.9$ na sua raiz foi testada usando diferentes tipos de números de ponto flutante:

    \begin{itemize}
        \item \verb|float|: $f(0.3) \approx -3.57628 \cdot 10^{-8}$ 
        \item \verb|double|: $f(0.3) \approx 1.11022 \cdot 10^{-16}$ 
        \item \verb|long double|: $f(0.3) \approx 5.35872 \cdot 10^{-312}$ 
    \end{itemize}
    
    Mesmo que o \verb|long double| consiga o melhor resultado, considerou-se que trabalhar com \verb|double| já é \emph{suficiente}. Foi feita uma sensibilidade do critério de convergência ($c_{lim}$) e foi possível trabalhar com limites de valores baixos sem aparente perda da qualidade da resposta por problemas com aritmética de máquina (\ref{fig:convergencia}).

    É sempre feita uma verificação ao final do código para avaliar qual é o valor entre $x_a$, $x_b$ e $x_{medio}$ que minimiza $|f(x)|$. O método da bisecção tem garantia de convergência, mas não é garantido que o melhor resultado será o $x_{medio}$ da última iteração. Um exemplo prático deste efeito é visto na Tabela \ref{tab:fquad}, onde o melhor resultado é alcançado na 8$^a$ iteração, mas o critério de convergência\footnote{A coluna com os valores da convergência foi omitida por falta de espaço na página} só é alcançado na 11$^a$ iteração.
    
    \begin{table}[h!] 
        \centering
        \begin{tabular}{ c c c c c c c }
            Int. & $x_a$   & $f(x_a)$    & $x_b$      & $f(x_b)$    & $x_{medio}$ & $f(x_{medio})$  \\
            \hline
             1 &     -0.25 &     -0.1875 &          1 &        8.25 &      0.375 &     2.07812   \\
             2 &     -0.25 &     -0.1875 &      0.375 &     2.07812 &     0.0625 &    0.457031   \\
             3 &     -0.25 &     -0.1875 &     0.0625 &    0.457031 &   -0.09375 &   0.0126953   \\
             4 &     -0.25 &     -0.1875 &   -0.09375 &   0.0126953 &  -0.171875 &    -0.11792   \\
             5 & -0.171875 &    -0.11792 &   -0.09375 &   0.0126953 &  -0.132812 &  -0.0602417   \\
             6 & -0.132812 &  -0.0602417 &   -0.09375 &   0.0126953 &  -0.113281 &  -0.0256805   \\
             7 & -0.113281 &  -0.0256805 &   -0.09375 &   0.0126953 &  -0.103516 & -0.00696945   \\
             8 & -0.103516 & -0.00696945 &   -0.09375 &   0.0126953 & -0.0986328 &  0.00274372   \\
             9 & -0.103516 & -0.00696945 & -0.0986328 &  0.00274372 &  -0.101074 & -0.00214267   \\
            10 & -0.101074 & -0.00214267 & -0.0986328 &  0.00274372 & -0.0998535 & 0.000293076   \\
            11 & -0.101074 & -0.00214267 & -0.0998535 & 0.000293076 &  -0.100464 & -0.000926659 
        \end{tabular}
        \caption{Busca pela raiz de $5x^2+3x-0.25$ no intervalo $[-0.25; 1]$ pelo Método da Bissecção.}
        \label{tab:fquad}
    \end{table}
    
    A metodologia proposta para o cálculo de parâmetros de perfuração com o Método da Mínima Curvatura tem algumas particularidades, como a sua indefinição quando é testado com um valor muito baixo de $\Delta S f(\alpha)$. A definição do intervalo de busca é direta, mas, devido a erros de aritmética de máquina, não é possível garantir que $sinal(f(x_a)) \neq sinal(f(x_b))$ quando a resposta está muito próxima de um dos limites. Desta forma, ao invés de gerar uma mensagem de erro quando $sinal(f(x_a)) = sinal(f(x_b))$, é gerada uma mensagem e o código retorna o valor de $x$ (igual a $x_a$ ou $x_b$) que minimizar $|f(x)|$.
    
    Este problema ficou evidente no cálculo do 4$^o$ trecho do poço em 'S' descrito nos testes de \verb|tests_minimum_curvature()| (\ref{fig:pocoS}). O valor exato de $\theta_2$ é zero (o 5$^0$ trecho é reto e vertical). Neste caso, o valor mínimo de $\Delta S f(\alpha)$ é limitado pela equação \ref{eq:cos_theta2}, e é igual à resposta exata. Neste ponto o algoritmo calcula $f(263.305) \approx -2.58273 \cdot 10^{-7}$, que não atinge o critério de parada prematura, mas tem o mesmo sinal de $f(\Delta S f(\alpha)_{max})$.

    Foi implementada uma função para estimar o número de iterações necessárias para alcançar o critério de convergência definido (equação \ref{eq:nint}). Quando o critério de convergência ($c_{lim}$) é \emph{direto}, a estimativa se mostrou exata (exceto nos casos em que há parada prematura), o que indica que o algoritmo implantado converge com a taxa que era esperada (\ref{fig:Erro}). Buscou-se realizar a mesma estimativa para o caso de uso do critério de convergência \emph{relativo}, e neste caso as estimativas não exatas, mas tem boa previsão (ver Tabela \ref{table:Iteracoes}).
    
    \begin{equation} \label{eq:nint}
        n_{int} = \left \lceil \frac{\log{\frac{|x_b-x_a|}{|x_{referencia}|}\frac{1}{c_{lim}}}}{\log{2}} \right \rceil
    \end{equation}
    \begin{align*}
        \intertext{onde}
        x_{referencia} = \begin{cases}
            1,&\text{se Critério de convergência direto} \\
            \min(|x_a|,|x_b|),&\text{c.c. }  
        \end{cases}
    \end{align*}

    \begin{table}[h] \label{table:Iteracoes}
        \centering
        \caption{Comparação entre o número de iterações previsto e realizado para diferentes testes.}
        \begin{tabular}{ l c c c c c c }
            \multirow{2}{*}{Função} & \multirow{2}{*}{$x_a$} & \multirow{2}{*}{$x_b$} & \multicolumn{2}{c}{Critério \emph{Direto}} & \multicolumn{2}{c}{Critério \emph{Relativo}} \\
            &  &  & Previsão & Realizado & Previsão & Realizado \\
            \hline
            Linear & 0. & 2. & 11 & 11 & 11 & 13 \\
            Quadrática & -0.25 & 1. & 11 & 11 & 11 & 14 \\
            Exponencial & 0. & 10. & 14 & 14 & 14 & 13 \\
            Trigonométrica & 0. & 5. & 13 & 13 & 13 & 12 \\
            1/4 círculo horizontal & 14.1421 & 120.417 & 17 & 17 & 13 & 13 \\
            Seção 2 do poço em S & 130.526 & 1111.4 & 20 & 20 & 13 & 13 \\
            Poço 3D & 9.84918 & 83.8634 & 17 & 17 & 13 & 13 \\
        \end{tabular}
    \end{table}
        
    \section{Conclusão}
    
    O algoritmo proposto para o cálculo de parâmetros de perfuração em função das coordenadas cartesianas de pontos ao longo do se mostrou eficaz. Foram feitos ajustes ao código implementado de forma a evitar o uso de funções trigonométricas ao longo do processo iterativo.
    O Método da Bisseção se mostrou adequado para uso com o algoritmo proposto. As funções propostas não são válidas para quaisquer valores de entrada, e a delimitação de uma região de busca foi importante para garantir a convergência do problema.

    % \label{}
    
%% The Appendices part is started with the command \appendix;
%% appendix sections are then done as normal sections
%% \appendix

%% \section{}
%% \label{}

%% If you have bibdatabase file and want bibtex to generate the
%% bibitems, please use
%%

\bibliographystyle{elsarticle-num} 
\bibliography{refs}

%% else use the following coding to input the bibitems directly in the
%% TeX file.

% \begin{thebibliography}{00}

%% \bibitem{label}
%% Text of bibliographic item

% \bibitem{}

% \end{thebibliography}

\newpage

\appendix

\FloatBarrier
\section{Gráficos Diagnóstico}

\subsection{Erro ao Longo da Iterações}

A figura abaixo apresenta a evolução do erro, com relação à resposta exata, ao longo do processo iterativo de diferentes funções, utilizando o Método da Bissecção. São apresentadas duas retas tracejadas onde a razão entre os erros de iterações sucessivas é 0.5, que é o que se espera do Método da Bissecção após um número considerável de iterações. Observa-se que os resultados numéricos não seguem exatamente uma linha reta, mas têm aproximadamente a mesma inclinação das retas tracejadas.

\begin{figure}[hbt!] 
    \label{fig:Erro}
    \centering
    \begin{tikzpicture}
        \begin{axis}[
            height = 10cm, % standard 10cm
            width = 0.8\textwidth, %15cm,  % standard 10cm
            % xmode=log,
            ymode=log,
            grid=both,
            % ymin=1e-12,
            % ymax=1e0,
            xlabel = {Iterações},
            ylabel = {$\varepsilon_i = |P_i - P|$},
            legend style={at={(0.99,0.80)}, anchor=east},
            ]
            \addplot[color=black, solid, mark=*] table [x=Iteration, y =Linear] {IterationError.txt};
            \addplot[color=blue, solid, mark=*] table [x=Iteration, y =Quadratic] {IterationError.txt};
            \addplot[color=green, solid, mark=*] table [x=Iteration, y =Exponential] {IterationError.txt};
            \addplot[color=red, solid, mark=*] table [x=Iteration, y =Trigonometric] {IterationError.txt};
            \addplot[color=purple, solid, mark=*] table [x=Iteration, y =3Dwell] {IterationError.txt};
            \addplot[color=black, dashed] table [x=Iteration, y =TX05A] {IterationError.txt};
            \addplot[color=black, dashed] table [x=Iteration, y =TX05B] {IterationError.txt};
            \legend{Linear, Quadrática, Exponencial, Trigonométrica, Poço 3D};
        \end{axis}
        
    \end{tikzpicture}
    \caption{Evolução do erro do Método da Bissecção com diferentes funções (linhas tracejadas representam $\varepsilon_{i+1} / \varepsilon_i = 0.5$).}
\end{figure}

\newpage
\FloatBarrier
\subsection{Erro em Função do Limite de Convergência}

A figura a seguir mostra os erros (com relação ao valor exato) nas estimativas de diferentes parâmetros de perfuração. O algoritmo proposto foi aplicado a um trecho de poço com mudança em inclinação e direção, utilizando diferentes valores de limite de convergência ($c_{lim}$).

\begin{figure}[hbt!]
    \label{fig:convergencia}
    \centering
    \begin{tikzpicture}
        \begin{axis}[
            height = 10cm, % standard 10cm
            width = 0.8\textwidth, %15cm,  % standard 10cm
            xmode=log,
            ymode=log,
            grid=both,
            ymin=1e-12,
            ymax=1e0,
            xlabel = {$c_{lim}$},
            ylabel = {Erro},
            legend style={at={(0.25,0.55)}, anchor=east},
            ]
            \addplot[color=black, solid, mark=*] table [x=Convergence, y = DeltaSfa] {ConvergenceErrors.txt};
            \addplot[color=purple, solid, mark=*] table [x=Convergence, y = DeltaS] {ConvergenceErrors.txt};
            \addplot[color=blue, solid, mark=*] table [x=Convergence, y = theta2] {ConvergenceErrors.txt};
            \addplot[color=green, solid, mark=*] table [x=Convergence, y = phi2] {ConvergenceErrors.txt};
            \legend{$\Delta S f(\alpha)$, $\Delta S$, $\theta_2$, $\phi_2$};
        \end{axis}
        
        \begin{axis}[
            height = 10cm, % standard 10cm
            xmode=log,
            width = 0.8\textwidth, %15cm,  % standard 10cm
            axis y line=right,
            ylabel={Iterações até Convergência},
            ymin=0,
            ymax=50,
            % yticklabel style={red},
            legend style={at={(0.98,0.10)}, anchor=east},
            ]
            \addplot[color=red, solid, mark=*] table [x=Convergence, y = Iterations] {ConvergenceErrors.txt};
            \legend{Iterações}
        \end{axis}

    \end{tikzpicture}
    \caption{Erro das variáveis de interesse em função do limite de convergência utilizado.}
\end{figure}

\newpage
\FloatBarrier
\section{Esquema do Poço em S}

Um dos exemplos testados com o algoritmo proposto para calcular parâmetros de perfuração em função de coordenadas cartesianas é um poço em S. Uma representação esquemática da trajetória do poço (sem escala) é apresentada abaixo.

\begin{figure}[hbt!]
    \label{fig:pocoS}
    \centering
    \includegraphics[width=0.4\textwidth]{EsquemaPoco}
    \caption{Esquema do poço em 'S' descrito nos testes de tests\textunderscore minimum\textunderscore curvature().}
\end{figure}

\newpage
\FloatBarrier
\section{Código em C}

O código de ambos métodos foi implementado em um único arquivo. O código é apresentado em duas partes neste documento para facilitar a leitura. O código pode ser encontrado em \href{https://github.com/TiagoCAAmorim/numerical-methods}{https://github.com/TiagoCAAmorim/numerical-methods}.

\subsection{Método da Bissecção}
\lstinputlisting[language=C, linerange={1-276}]{./01_bissection.c}

\subsection{Método da Mínima Curvatura}
\lstinputlisting[language=C, linerange={279-676}]{./01_bissection.c}

\end{document}
\endinput